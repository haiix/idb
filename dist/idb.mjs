var e={d:(t,r)=>{for(var s in r)e.o(r,s)&&!e.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:r[s]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},t={};e.d(t,{aZ:()=>i,OP:()=>c,Fj:()=>h,Ay:()=>u,ho:()=>d,rE:()=>r});const r="0.0.1";function s(e){return e.error??e.transaction?.error??new Error("Request failed.")}function o(e){return new Promise(((t,r)=>{e.onsuccess=()=>{t(e.result)},e.onerror=()=>{r(s(e))}}))}async function*n(e){for(let t;t=await o(e);)yield t}class i{name;version;upgReqs=[];reqs=[];commitRequested=!1;latestError;constructor(e){this.name=e}open(){return new Promise(((e,t)=>{const r=indexedDB.open(this.name,this.version);r.onsuccess=()=>{e(r.result)},r.onerror=()=>{t(s(r))},r.onupgradeneeded=()=>{for(const[,,e]of this.upgReqs)e(r.result)}}))}async transaction(e,t,r){const s=await this.open();return new Promise(((o,n)=>{if("string"!=typeof e&&![...e].length)return s.close(),void o();const i=s.transaction(e,t);i.oncomplete=()=>{s.close(),o()},i.onerror=()=>{s.close(),i.error&&n(i.error)};try{r(i)}catch(e){throw i.abort(),s.close(),e}}))}async getVersion(){const e=await this.open(),t=e.version;return e.close(),t}async objectStoreNames(){const e=await this.open(),{objectStoreNames:t}=e;return e.close(),t}objectStore(e,t,r){return new h(this,e,t,r)}deleteObjectStore(e){return this.upgReqs.push([e,"delete",t=>{t.deleteObjectStore(e)}]),this.commit()}requestToCommit(){(async()=>{this.commitRequested||(this.commitRequested=!0,await Promise.resolve(),this.commitRequested=!1,await this.commit())})().catch((e=>{this.latestError=e}))}async commit(){let e=!1;if(this.upgReqs.length){const t=await this.objectStoreNames();for(const[r,s]of this.upgReqs)"create"!==s||t.contains(r)?"delete"===s&&t.contains(r)&&(e=!0):e=!0;e&&(this.version=await this.getVersion()+1)}if(e||this.reqs.length){const e=[...this.reqs.reduce(((e,[t])=>e.add(t)),new Set)],t=this.reqs.every((([,e])=>"readonly"===e))?"readonly":"readwrite";await this.transaction(e,t,(e=>{for(const[,,t]of this.reqs)t(e);this.reqs.length=0}))}}deleteDatabase(){return o(indexedDB.deleteDatabase(this.name))}}class a{async count(e){return await this.register("readonly",(t=>o(t.count(e))))}async get(e){return await this.register("readonly",(t=>o(t.get(e))))}async getAll(e,t){return await this.register("readonly",(r=>o(r.getAll(e,t))))}async getAllKeys(e,t){return await this.register("readonly",(r=>o(r.getAllKeys(e,t))))}async getKey(e){return await this.register("readonly",(t=>o(t.getKey(e))))}async*openCursor(e,t){yield*await this.register("readwrite",(r=>n(r.openCursor(e,t))))}async*openKeyCursor(e,t){yield*await this.register("readwrite",(r=>n(r.openKeyCursor(e,t))))}}class c extends a{db;storeName;name;constructor(e,t,r){super(),this.db=e,this.storeName=t,this.name=r}register(e,t){const r=new Promise(((r,s)=>{this.db.reqs.push([this.storeName,e,e=>{try{r(t(e.objectStore(this.storeName).index(this.name)))}catch(e){s(e)}}])}));return this.db.requestToCommit(),r}}class h extends a{db;name;constructor(e,t,r,s){super(),this.db=e,this.name=t,this.db.upgReqs.push([t,"create",e=>{if(!e.objectStoreNames.contains(t)){const o=e.createObjectStore(t,r);if(s)for(const e of s)o.createIndex(e.name,e.keyPath,e.options)}}]),this.db.requestToCommit()}register(e,t){const r=new Promise(((r,s)=>{this.db.reqs.push([this.name,e,e=>{try{r(t(e.objectStore(this.name)))}catch(e){s(e)}}])}));return this.db.requestToCommit(),r}async add(e,t){return await this.register("readwrite",(r=>o(r.add(e,t))))}async clear(){await this.register("readwrite",(e=>o(e.clear())))}async delete(e){await this.register("readwrite",(t=>o(t.delete(e))))}index(e){return new c(this.db,this.name,e)}async put(e,t){return await this.register("readwrite",(r=>o(r.put(e,t))))}}function d(e){return new i(e)}const u={open:d};var l=t.aZ,m=t.OP,y=t.Fj,w=t.Ay,g=t.ho,p=t.rE;export{l as Idb,m as IdbIndex,y as IdbStore,w as default,g as open,p as version};