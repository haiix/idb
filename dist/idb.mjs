var e={d:(t,r)=>{for(var s in r)e.o(r,s)&&!e.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:r[s]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},t={};e.d(t,{aZ:()=>i,OP:()=>c,Fj:()=>h,Ay:()=>d,ho:()=>u,rE:()=>r});const r="0.0.1";function s(e){return e.error??e.transaction?.error??new Error("Request failed.")}function o(e){return new Promise(((t,r)=>{e.onsuccess=()=>{t(e.result)},e.onerror=()=>{r(s(e))}}))}async function*n(e){for(let t;t=await o(e);)yield t}class i{name;version;latestError;upgReqs=[];reqs=[];commitRequested=!1;constructor(e){this.name=e}open(){return new Promise(((e,t)=>{const r=indexedDB.open(this.name,this.version);r.onsuccess=()=>{e(r.result)},r.onerror=()=>{t(s(r))},r.onupgradeneeded=()=>{for(const[,,e]of this.upgReqs)e(r.result)}}))}async transaction(e,t,r){const s=await this.open();return new Promise(((o,n)=>{if("string"!=typeof e&&![...e].length)return s.close(),void o();const i=s.transaction(e,t);i.oncomplete=()=>{s.close(),o()},i.onerror=()=>{s.close(),i.error&&n(i.error)};try{r(i)}catch(e){throw i.abort(),s.close(),e}}))}async getVersion(){const e=await this.open(),t=e.version;return e.close(),t}async objectStoreNames(){const e=await this.open(),{objectStoreNames:t}=e;return e.close(),t}objectStore(e,t,r){return this.upgReqs.push([e,"create",s=>{if(!s.objectStoreNames.contains(e)){const o=s.createObjectStore(e,t);if(r)for(const e of r)o.createIndex(e.name,e.keyPath,e.options)}}]),this.requestToCommit(),new h(this,e)}deleteObjectStore(e){return this.upgReqs.push([e,"delete",t=>{t.deleteObjectStore(e)}]),this.commit()}requestToCommit(e){(async()=>{e&&this.reqs.push(e),this.commitRequested||(this.commitRequested=!0,await Promise.resolve(),this.commitRequested=!1,await this.commit())})().catch((e=>{this.latestError=e}))}async commit(){let e=!1;if(this.upgReqs.length){const t=await this.objectStoreNames();for(const[r,s]of this.upgReqs)"create"!==s||t.contains(r)?"delete"===s&&t.contains(r)&&(e=!0):e=!0;e&&(this.version=await this.getVersion()+1)}if(e||this.reqs.length){const e=[...this.reqs.reduce(((e,[t])=>e.add(t)),new Set)],t=this.reqs.every((([,e])=>"readonly"===e))?"readonly":"readwrite";await this.transaction(e,t,(e=>{for(const[,,t]of this.reqs)t(e);this.reqs.length=0}))}}deleteDatabase(){return o(indexedDB.deleteDatabase(this.name))}}class a{register(e,t){return new Promise(((r,s)=>{this.db.requestToCommit([this.storeName,e,e=>{try{r(t(this.getTarget(e)))}catch(e){s(e)}}])}))}count(e){return this.register("readonly",(t=>o(t.count(e))))}get(e){return this.register("readonly",(t=>o(t.get(e))))}getAll(e,t){return this.register("readonly",(r=>o(r.getAll(e,t))))}getAllKeys(e,t){return this.register("readonly",(r=>o(r.getAllKeys(e,t))))}getKey(e){return this.register("readonly",(t=>o(t.getKey(e))))}async*openCursor(e,t){yield*await this.register("readwrite",(r=>n(r.openCursor(e,t))))}async*openKeyCursor(e,t){yield*await this.register("readwrite",(r=>n(r.openKeyCursor(e,t))))}}class c extends a{db;storeName;name;constructor(e,t,r){super(),this.db=e,this.storeName=t,this.name=r}getTarget(e){return e.objectStore(this.storeName).index(this.name)}}class h extends a{db;storeName;name;constructor(e,t){super(),this.db=e,this.storeName=t,this.name=t}getTarget(e){return e.objectStore(this.storeName)}add(e,t){return this.register("readwrite",(r=>o(r.add(e,t))))}clear(){return this.register("readwrite",(e=>o(e.clear())))}delete(e){return this.register("readwrite",(t=>o(t.delete(e))))}index(e){return new c(this.db,this.name,e)}put(e,t){return this.register("readwrite",(r=>o(r.put(e,t))))}}function u(e){return new i(e)}const d={open:u};var l=t.aZ,m=t.OP,g=t.Fj,y=t.Ay,p=t.ho,w=t.rE;export{l as Idb,m as IdbIndex,g as IdbStore,y as default,p as open,w as version};