{"version":3,"file":"idb.mjs","mappings":"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","sources":["webpack://@haiix/idb/webpack/bootstrap","webpack://@haiix/idb/webpack/runtime/define property getters","webpack://@haiix/idb/webpack/runtime/hasOwnProperty shorthand","webpack://@haiix/idb/./src/idb.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","/*\n * idb.ts\n *\n * Copyright (c) 2025 haiix\n *\n * This software is released under the MIT license.\n * See: https://opensource.org/licenses/MIT\n */\n\nexport const version = '0.1.0';\n\nconst READONLY = 0;\nconst READWRITE = 1;\nconst CREATE = 0;\nconst DELETE = 1;\n\ntype TransactionMode = typeof READONLY | typeof READWRITE;\ntype UpgMethod = typeof CREATE | typeof DELETE;\n\ntype UpgReq = [\n  string, // ObjectStoreName\n  UpgMethod, // Method\n  (db: IDBDatabase) => unknown,\n];\n\ntype UpgIReq = [\n  string, // IndexName\n  UpgMethod, // Method\n  (objectStore: IDBObjectStore) => unknown,\n];\n\ntype Req = [\n  string, // ObjectStoreName\n  TransactionMode, // Mode\n  (tx: IDBTransaction) => unknown,\n];\n\nexport type IndexParameters = {\n  name: string;\n  keyPath: string | Iterable<string>;\n  options?: IDBIndexParameters;\n};\n\nfunction createDictionary<T>(): Record<string, T> {\n  return Object.create(null) as Record<string, T>;\n}\n\nfunction reqToAsync<T>(req: IDBRequest<T>): Promise<T> {\n  return new Promise((resolve, reject) => {\n    req.onsuccess = () => {\n      resolve(req.result);\n    };\n    req.onerror = () => {\n      reject(\n        req.error ?? req.transaction?.error ?? new Error('Request failed.'),\n      );\n    };\n  });\n}\n\nasync function* reqToAsyncGen<T>(\n  req: IDBRequest<T | null>,\n): AsyncGenerator<T, void> {\n  // eslint-disable-next-line no-await-in-loop\n  for (let cursor; (cursor = await reqToAsync(req)); ) {\n    yield cursor;\n  }\n}\n\nexport class Idb {\n  readonly name: string;\n\n  private upgReqs: UpgReq[] = [];\n  private upgIReqs = createDictionary<UpgIReq[]>();\n  private reqs: Req[] = [];\n  private isRequested = false;\n\n  constructor(name: string) {\n    this.name = name;\n  }\n\n  private async open<T>(\n    callback: (db: IDBDatabase) => T | Promise<T>,\n    dbVersion?: number,\n    onupgradeneeded?: (db: IDBDatabase, tx: IDBTransaction) => void,\n  ): Promise<T> {\n    const req = indexedDB.open(this.name, dbVersion);\n    if (onupgradeneeded) {\n      req.onupgradeneeded = () => {\n        onupgradeneeded(req.result, req.transaction as IDBTransaction);\n      };\n    }\n    try {\n      return await callback(await reqToAsync(req));\n    } finally {\n      req.result.close();\n    }\n  }\n\n  private tx<T>(\n    db: IDBDatabase,\n    objectStoreNames: string[],\n    mode: IDBTransactionMode,\n    callback: (tx: IDBTransaction) => T,\n  ): Promise<T> {\n    let result: T;\n    return new Promise((resolve, reject) => {\n      const tx = db.transaction(objectStoreNames, mode);\n      tx.oncomplete = () => {\n        resolve(result);\n      };\n      tx.onerror = () => {\n        reject(tx.error ?? new Error('Transaction failed.'));\n      };\n      try {\n        result = callback(tx);\n      } catch (error) {\n        tx.abort();\n        throw error;\n      }\n    });\n  }\n\n  private addUpgIRec(objectStoreName: string, upgIRec: UpgIReq) {\n    if (!this.upgIReqs[objectStoreName]) {\n      this.upgIReqs[objectStoreName] = [];\n    }\n    this.upgIReqs[objectStoreName].push(upgIRec);\n  }\n\n  version(): Promise<number> {\n    return this.open((db) => db.version);\n  }\n\n  objectStoreNames(): Promise<DOMStringList> {\n    return this.open((db) => db.objectStoreNames);\n  }\n\n  objectStore(\n    name: string,\n    options?: IDBObjectStoreParameters | null,\n    indices?: IndexParameters[],\n  ): IdbStore {\n    this.upgReqs.push([\n      name,\n      CREATE,\n      (db) => {\n        if (!db.objectStoreNames.contains(name)) {\n          if (options) {\n            db.createObjectStore(name, options);\n          } else {\n            db.createObjectStore(name);\n          }\n        }\n      },\n    ]);\n    if (indices) {\n      for (const index of indices) {\n        this.addUpgIRec(name, [\n          index.name,\n          CREATE,\n          (objectStore) => {\n            if (!objectStore.indexNames.contains(index.name)) {\n              objectStore.createIndex(index.name, index.keyPath, index.options);\n            }\n          },\n        ]);\n      }\n    }\n    return new IdbStore(this, name, name);\n  }\n\n  deleteObjectStore(name: string): Promise<void> {\n    this.upgReqs.push([\n      name,\n      DELETE,\n      (db) => {\n        if (db.objectStoreNames.contains(name)) {\n          db.deleteObjectStore(name);\n        }\n      },\n    ]);\n    return this.commit();\n  }\n\n  deleteIndex(objectStoreName: string, indexName: string): Promise<void> {\n    this.addUpgIRec(objectStoreName, [\n      indexName,\n      DELETE,\n      (objectStore) => {\n        if (objectStore.indexNames.contains(indexName)) {\n          objectStore.deleteIndex(indexName);\n        }\n      },\n    ]);\n    return this.commit();\n  }\n\n  private isNeedToUpg(db: IDBDatabase): boolean {\n    for (const [name, method] of this.upgReqs) {\n      const contains = db.objectStoreNames.contains(name);\n\n      if (method === CREATE && !contains) {\n        return true;\n      } else if (method === DELETE && contains) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private async isNeedToIUpg(db: IDBDatabase): Promise<boolean> {\n    const targetObjectStoreNames = Object.keys(this.upgIReqs);\n    if (!targetObjectStoreNames.length) return false;\n\n    return this.tx(db, targetObjectStoreNames, 'readonly', (tx) => {\n      for (const objectStoreName of targetObjectStoreNames) {\n        const objectStore = tx.objectStore(objectStoreName);\n\n        for (const [indexName, method] of this.upgIReqs[\n          objectStoreName\n        ] as UpgIReq[]) {\n          const contains = objectStore.indexNames.contains(indexName);\n\n          if (method === CREATE && !contains) {\n            return true;\n          } else if (method === DELETE && contains) {\n            return true;\n          }\n        }\n      }\n      return false;\n    });\n  }\n\n  async requestToCommit(req?: Req): Promise<void> {\n    if (req) {\n      this.reqs.push(req);\n    }\n    if (this.isRequested) return;\n    this.isRequested = true;\n    await Promise.resolve();\n    this.isRequested = false;\n    await this.commit();\n  }\n\n  private async commit(): Promise<void> {\n    let dbVersion = 0;\n    if (this.upgReqs.length) {\n      dbVersion = await this.open(async (db) => {\n        if (this.isNeedToUpg(db) || (await this.isNeedToIUpg(db))) {\n          return db.version + 1;\n        }\n        this.upgReqs = [];\n        this.upgIReqs = createDictionary<UpgIReq[]>();\n        await this.procReqs(db);\n        return 0;\n      });\n    }\n    if (this.reqs.length || this.upgReqs.length) {\n      if (this.upgReqs.length) {\n        await this.open(\n          (db) => this.procReqs(db),\n          dbVersion,\n          (db, tx) => {\n            this.procUpgReqs(db, tx);\n          },\n        );\n      } else {\n        await this.open((db) => this.procReqs(db));\n      }\n    }\n  }\n\n  private procUpgReqs(db: IDBDatabase, tx: IDBTransaction): void {\n    for (const [, , fn] of this.upgReqs) {\n      fn(db);\n    }\n    this.upgReqs = [];\n\n    for (const [storeName, reqs] of Object.entries(this.upgIReqs)) {\n      const objectStore = tx.objectStore(storeName);\n      for (const [, , fn] of reqs) {\n        fn(objectStore);\n      }\n    }\n    this.upgIReqs = createDictionary<UpgIReq[]>();\n  }\n\n  private async procReqs(db: IDBDatabase): Promise<void> {\n    if (!this.reqs.length) return;\n\n    const objectStoreNames = [...new Set(this.reqs.map(([name]) => name))];\n    const mode = this.reqs.every(([, mode]) => mode === READONLY)\n      ? 'readonly'\n      : 'readwrite';\n\n    await this.tx(db, objectStoreNames, mode, (tx) => {\n      for (const [, , fn] of this.reqs) {\n        fn(tx);\n      }\n      this.reqs = [];\n    });\n  }\n\n  deleteDatabase(): Promise<IDBDatabase> {\n    return reqToAsync(indexedDB.deleteDatabase(this.name));\n  }\n}\n\nabstract class IdbStoreBase<U extends IDBObjectStore | IDBIndex> {\n  protected db: Idb;\n  protected osName: string;\n  readonly name: string;\n\n  constructor(db: Idb, osName: string, name: string) {\n    this.db = db;\n    this.osName = osName;\n    this.name = name;\n  }\n\n  protected abstract getTarget(tx: IDBTransaction): U;\n\n  protected reg<T>(\n    mode: TransactionMode,\n    callback: (os: U) => T | Promise<T>,\n  ): Promise<T> {\n    return new Promise((resolve, reject: (reason: unknown) => void) => {\n      this.db\n        .requestToCommit([\n          this.osName,\n          mode,\n          (tx) => {\n            try {\n              resolve(callback(this.getTarget(tx)));\n            } catch (error) {\n              reject(error);\n            }\n          },\n        ])\n        .catch(reject);\n    });\n  }\n\n  protected regq<T>(\n    mode: TransactionMode,\n    callback: (os: U) => IDBRequest<T>,\n  ): Promise<T> {\n    return this.reg(mode, (os) => reqToAsync(callback(os)));\n  }\n\n  protected async *regc<T>(\n    mode: TransactionMode,\n    callback: (os: U) => IDBRequest<T | null>,\n  ): AsyncGenerator<T, void, unknown> {\n    yield* await this.reg(mode, (os) => reqToAsyncGen(callback(os)));\n  }\n\n  count(query?: IDBValidKey | IDBKeyRange): Promise<number> {\n    return this.regq(READONLY, (os) => os.count(query));\n  }\n\n  get(query: IDBValidKey | IDBKeyRange): Promise<unknown> {\n    return this.regq(READONLY, (os) => os.get(query));\n  }\n\n  getAll(\n    query?: IDBValidKey | IDBKeyRange | null,\n    count?: number,\n  ): Promise<unknown[]> {\n    return this.regq(READONLY, (os) => os.getAll(query, count));\n  }\n\n  getAllKeys(\n    query?: IDBValidKey | IDBKeyRange | null,\n    count?: number,\n  ): Promise<IDBValidKey[]> {\n    return this.regq(READONLY, (os) => os.getAllKeys(query, count));\n  }\n\n  getKey(query: IDBValidKey | IDBKeyRange): Promise<IDBValidKey | undefined> {\n    return this.regq(READONLY, (os) => os.getKey(query));\n  }\n\n  keyPath(): Promise<string | string[]> {\n    return this.reg(READONLY, (os) => os.keyPath);\n  }\n\n  openCursor(\n    query?: IDBValidKey | IDBKeyRange | null,\n    direction?: IDBCursorDirection,\n  ): AsyncGenerator<IDBCursorWithValue, void, unknown> {\n    return this.regc(READWRITE, (os) => os.openCursor(query, direction));\n  }\n\n  openKeyCursor(\n    query?: IDBValidKey | IDBKeyRange | null,\n    direction?: IDBCursorDirection,\n  ): AsyncGenerator<IDBCursor, void, unknown> {\n    return this.regc(READWRITE, (os) => os.openKeyCursor(query, direction));\n  }\n}\n\nexport class IdbStore extends IdbStoreBase<IDBObjectStore> {\n  protected getTarget(tx: IDBTransaction): IDBObjectStore {\n    return tx.objectStore(this.name);\n  }\n\n  add(value: unknown, key?: IDBValidKey): Promise<IDBValidKey> {\n    return this.regq(READWRITE, (os) => os.add(value, key));\n  }\n\n  autoIncrement(): Promise<boolean> {\n    return this.reg(READONLY, (os) => os.autoIncrement);\n  }\n\n  clear(): Promise<void> {\n    return this.regq(READWRITE, (os) => os.clear());\n  }\n\n  delete(query: IDBValidKey | IDBKeyRange): Promise<void> {\n    return this.regq(READWRITE, (os) => os.delete(query));\n  }\n\n  deleteIndex(indexName: string): Promise<void> {\n    return this.db.deleteIndex(this.name, indexName);\n  }\n\n  index(name: string): IdbIndex {\n    return new IdbIndex(this.db, this.name, name);\n  }\n\n  indexNames(): Promise<DOMStringList> {\n    return this.reg(READONLY, (os) => os.indexNames);\n  }\n\n  put(value: unknown, key?: IDBValidKey): Promise<IDBValidKey> {\n    return this.regq(READWRITE, (os) => os.put(value, key));\n  }\n}\n\nexport class IdbIndex extends IdbStoreBase<IDBIndex> {\n  protected getTarget(tx: IDBTransaction): IDBIndex {\n    return tx.objectStore(this.osName).index(this.name);\n  }\n\n  multiEntry(): Promise<boolean> {\n    return this.reg(READONLY, (os) => os.multiEntry);\n  }\n\n  unique(): Promise<boolean> {\n    return this.reg(READONLY, (os) => os.unique);\n  }\n}\n\nexport function open(dbname: string) {\n  return new Idb(dbname);\n}\n\nexport default {\n  open,\n};\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","version","createDictionary","create","reqToAsync","req","Promise","resolve","reject","onsuccess","result","onerror","error","transaction","Error","Idb","name","upgReqs","upgIReqs","reqs","isRequested","constructor","this","open","callback","dbVersion","onupgradeneeded","indexedDB","close","tx","db","objectStoreNames","mode","oncomplete","abort","addUpgIRec","objectStoreName","upgIRec","push","objectStore","options","indices","contains","createObjectStore","index","indexNames","createIndex","keyPath","IdbStore","deleteObjectStore","commit","deleteIndex","indexName","isNeedToUpg","method","isNeedToIUpg","targetObjectStoreNames","keys","length","requestToCommit","async","procReqs","procUpgReqs","fn","storeName","entries","Set","map","every","deleteDatabase","IdbStoreBase","osName","reg","getTarget","catch","regq","os","regc","cursor","reqToAsyncGen","count","query","getAll","getAllKeys","getKey","openCursor","direction","openKeyCursor","add","value","autoIncrement","clear","delete","IdbIndex","put","multiEntry","unique","dbname"],"sourceRoot":""}